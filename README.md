## 注重思想的理解，而不是实现

## 创建型
### 单例模式
创建全局唯一的对象
Runtime

### 工厂模式
创建不同但是相关类型的对象
Calendar.getInstance()

### 建造者模式
创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象，而用setXX的方式无法知道最后的对象是否完整。
Calendar.Builder

### 原型模式
针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

## 结构型
### 代理模式
在不改变原始类的情况下，通过引用代理类来增加原始类的功能

### 桥接模式
两种解释：
1. 将抽象和实现解耦，让他们可以独立变化
2. 一个类存在两个或多个独立变化的维度，通过组合的方式让他们可以独立扩展
例子：JDBC的驱动加载
这里的抽象不一定是接口，也可以是一套抽象的类库

### 装饰器模式
继承自同一个父类，然后子类进行组合增强
Collections.unmodifiableCollection()

### 适配器模式
转换不兼容的接口
实现方式可基于继承和组合两种方式

### 门面模式
对于分散的接口进行组合，提供更高层次的接口，让系统更易用

### 组合模式
用于处理树形结构数据，不常用，不是对象的组合关系
可以统一单个对象和组合对象的处理逻辑，比如文件和目录

### 享元模式
复用对象，节省内存

## 行为型
### 观察者模式
也叫发布-订阅模式，在对象之间d定义一个一对多的依赖，当对象的状态发生变化时，所依赖的对象自动接收通知
Observer
Observable setChanged(), notifyObservers()

### 模版模式
在一个方法中定义一个算法骨架，将某些步骤延迟到子类中实现
Collections.sort();

### 策略模式
定义一组算法，是他们可以互相替换，使算法独立于客户端
可以分为3部分：
1. 接口的定义和类的实现
2. 工厂类来创建策略
3. 客户端如何使用策略

### 责任链模式
将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。让请求沿着处理链传递，直到有对象可以处理或者一直传到最后。
如过滤器，拦截器

### 状态模式
有限状态机（Finite State Machine）FSM ，三个部分：状态，事件，动作
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类
1、分支逻辑：直接使用if-else 处理
2、查表法：适合状态很多，转移复杂的状态机
3、状态模式：状态不多，事件不复杂

### 迭代器模式
遍历集合对象
删除或添加数据导致遍历的未决行为，解决方法：1、不允许删或增元素；2、遍历报错
java使用方法2，每次增/删元素时modCount+1，遍历时比较modCount，不一样报错。
remove删除游标指向的前一个元素，多次调用会报错，内部加一个lastRet记录前一个遍历的位置，
remove后置为-1，再次调用报错
实现方法1类似快照功能：a.每次调迭代器的时候直接复制一份数据；b.新增一个数组记录删除的元素和位置

### 访问者模式
允许一个或多个操作应用到一组对象上，解耦操作和对象本身
难点是重载是静态绑定的，但是需要在运行期才能确定函数对象。
导致代码结构复杂

### 备忘录模式
快照模式
在不违背封装的原则下捕获对象的内部状态，另外保存以便用来恢复先前的状态
快照一般消耗资源比较多，应采用低频率全量备份，高频率增量备份的方式。

### 命令模式
把请求封装成对象，能够支持请求的排队/日志等操作
对于没法传递函数的语言，把函数封装成对象，方便传递和控制执行

### 解释器模式
针对语法自定义解释器，避免大而全的解析类

### 中介模式
定义一个中介对象来封装一组对象之间的交互，避免对象之间的直接交互。





